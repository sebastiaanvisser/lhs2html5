<!--

> {-# LANGUAGE GeneralizedNewtypeDeriving #-}
> module Heap where

  import Control.Applicative

> import Control.Monad.Reader
> import Control.Monad.State
> import Data.Map (Map)
> import Data.Binary (Binary)
> import Prelude hiding (lookup)
> import System.IO
> import qualified Data.Map as M

-->

<!-- ====================================================================== -->

<div class="slide chapter">
<header><h1>Storage Heap</h1></header>
</div>

<!-- ====================================================================== -->

<div class=slide>
<header><h1>File based storage heap</h1><div class=slidenumber></div></header>
<div class=body>
  <div class="hindent vindent"
  <p>Heap as a linear list of blocks of binary data.</p>
  </div>
  <div class=hindent>
  <p>A single block contains:</p>
  <ul>
    <li><code>1 byte</code> used/free flag.</li>
    <li><code>4 byte</code> payload byte size.</li>
    <li><code>n byte</code> payload as binary stream.</li>
  </ul>
  </div>
  <div class=hindent>
  <p>Heap uses an in-memory map to perform allocation/freeing.</p>
  </div>
</div>
<footer></footer>
</div>

<div class=slide>
<header><h1>The heap layout</h1><div class=slidenumber></div></header>
<div class=body>
  <div>
  <center>
  <img class=long src="http://localhost/uu/msc/thesis/heap.pdf">
  </center>
  </div>
</div>
<footer></footer>
</div>

<!-- ====================================================================== -->

<div class=slide>
<header><h1>Pointer type</h1><div class=slidenumber></div></header>
<div class=body>
  <div class=vindent>
  <p>A <code>Pointer</code> as byte offset into file.</p>
  <pre language=haskell class=signature>

> type Offset = Integer
> type Size   = Integer

  </pre><pre language=haskell>

> newtype Pointer a = Ptr Offset

  </pre>
  </div>
</div>
<footer></footer>
</div>

<!-- ====================================================================== -->

<div class=slide>
<header><h1>Heap context</h1><div class=slidenumber></div></header>
<div class=body>
  <div class=vindent>
  <p>The <code>Heap</code> context stores a file handle and an allocation map.</p>
  <pre language=haskell class=signature>

> type AllocMap = Map Offset Size

  </pre><pre language=haskell>

> newtype Heap a = Heap ( ReaderT Handle
>                       ( StateT (Size, AllocMap)
>                         IO )
>                         a )

<!--

>   deriving
>     ( Functor, Monad
>     , MonadIO
>     , MonadReader Handle
>     , MonadState  (Size, AllocMap)
>     )

-->

  </pre>
  </div>
</div>
<footer></footer>
</div>

<!-- ====================================================================== -->

<div class=slide>
<header><h1>Heap operations</h1><div class=slidenumber></div></header>
<div class=body>
  <div class="vindent">
  <p>Basic operations:</p>
  <pre language=haskell class=signature>

> read     :: Binary a => Pointer a -> Heap a

  </pre><pre language=haskell class=signature>

> write    :: Binary a => a         -> Heap (Pointer a)

  </pre><pre language=haskell class=signature>
allocate ::             Integer   -> Heap (Pointer a)
  </pre><pre language=haskell>

> free     ::             Pointer a -> Heap ()

  </pre><pre language=haskell>

> run      :: FilePath -> Heap a    -> IO ()

  </pre>
  </div>
</div>
<footer></footer>
</div>

<!--

> read = undefined
> write = undefined
> free = undefined
> run = undefined

-->

<!-- ====================================================================== -->

<div class=slide>
<header><h1>Allocate</h1><div class=slidenumber></div></header>
<div class=body>
  <div class="vindent">
  <p>Allocate scans the in-memory allocation map for a free block.</p>
  <pre language=haskell class=signature>

> allocate :: Integer -> Heap (Pointer a)

  </pre><pre language=haskell>

> allocate size =
>   do (end, unused) <- get               -- from StateT
>      case atLeast size unused of
>        offset:_ -> useBlockAt offset -- from map
>        _        -> useBlockAt end          -- grow heap
>   where atLeast s = M.elems . M.filter (>= s)

  </pre><pre language=haskell class="signature helper">

> useBlockAt :: Integer -> Heap (Pointer a)

  </pre>

<!--

> useBlockAt = undefined

-->
  </div>
</div>
<footer></footer>
</div>


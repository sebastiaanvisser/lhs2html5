<!-- ====================================================================== -->

<div class=slide>
<header><h1>Allocate</h1><div class=slidenumber></div></header>
<div class=body>
  <div class="vindent">
  <p>Allocate scans the in-memory allocation map for a free block.</p>
  <pre language=haskell class=signature>

> allocate :: Integer -> Heap (Pointer a)

  </pre><pre language=haskell>

> allocate size =
>   do (end, unused) <- get               -- from StateT
>      case atLeast size unused of
>        offset:_ -> useBlockAt offset -- from map
>        _        -> useBlockAt end          -- grow heap
>   where atLeast s = M.elems . M.filter (>= s)

  </pre><pre language=haskell class="signature helper">

> useBlockAt :: Integer -> Heap (Pointer a)

  </pre>

<!--

> useBlockAt = undefined

-->
  </div>
</div>
<footer></footer>
</div>

<!-- ====================================================================== -->

<div class=slide>
<header><h1>Annotatation type classes</h1><div class=slidenumber></div></header>
<div class=body>
  <div class=vindent>
  <p>Modify a node inside an annotation.</p>
  <pre language=haskell class=signature>

> class (AnnOut a f m, AnnIn a f m) => AnnIO a f m where
>   annIO :: (f (FixA a f) -> m (f (FixA a f)))
>         -> FixA a f      -> m (FixA a f)

  </pre>
  </div>
  <div>
  <p>Default implementation performs unwrap/wrap:</p>
  <pre language=haskell>

>   annIO f = annIn <=< f <=< annOut

  </pre>
  </div>
</div>
<footer></footer>
</div>


<!-- ====================================================================== -->

<div class=slide>
<header><h1>Debug trace annotation</h1><div class=slidenumber></div></header>
<div class=body>
  <div class=vindent>
  <p>Annotation instances.</p>
  <pre language=haskell>

> instance (Functor f, Show (f ())) => AnnIO D f IO

  </pre>
  </div>
</div>
<footer></footer>
</div>


<!--

> {-# LANGUAGE
>     MultiParamTypeClasses
>   , FlexibleInstances
>   , FlexibleContexts
>   , UndecidableInstances
>   , DeriveFunctor
>   , DeriveFoldable
>   , DeriveTraversable
>   , KindSignatures
>   , RankNTypes
>   #-}
> module Morphisms where

> import Prelude hiding (mapM)
> import Data.Traversable
> import Control.Monad hiding (mapM)
> import Generics

-->

<!-- ====================================================================== -->

<div class="slide chapter">
<header><h1>Morphisms and Algebras</h1></header>
</div>

<!-- ====================================================================== -->

<div class=slide>
<header><h1>Abstracting away from recursion</h1><div class=slidenumber></div></header>
<div class=body>
  <div class=vindent>
  <p class="center problem">Writing operations on annotated structures is hard.</p>
  <p class="center problem">Touching the recursive positions requires wrapping/unwrapping.</p>
  </div>
</div>
<footer></footer>
</div>

<div class=slide>
<header><h1>Algebraic operations</h1><div class=slidenumber></div></header>
<div class=body>
  <div class=vindent>
  <p class="center solution">We will abstract away from recursion using <strong>morphisms</strong>.</p>
  </div>
</div>
<footer></footer>
</div>

<!-- ====================================================================== -->

<div class=slide>
<header><h1>Anamorphism</h1><div class=slidenumber></div></header>
<div class=body>
  <div>
  <p class=center>Like Haskell's <code>unfold</code>.</p>
  </div>
  <div class=vindent>
  <p>Coalgebra type:</p>
  <pre language=haskell>

> type Coalg s f = s -> f s

  </pre>
  </div>
  <div>
  <p>Corecursive anamorphic traversal:</p>
  <pre language=haskell class=signature>

> anaA :: (In a f m, Monad m, Traversable f)
>      => Coalg s f -> s -> m (FixA a f)

  </pre><pre language=haskell>

> anaA coalg = inA <=< mapM (anaA coalg) . coalg

  </pre>
  </div>
</div>
<footer></footer>
</div>

<!-- ====================================================================== -->

<div class=slide>
<header><h1>Binary tree from list.</h1><div class=slidenumber></div></header>
<div class=body>
  <div class=vindent>
  <pre language=haskell class=signature>

> fromListCoalg :: Coalg [v] (TreeF v)

  </pre><pre language=haskell>

> fromListCoalg []     = Leaf
> fromListCoalg (y:ys) =
>   let l = take (length ys `div` 2) ys
>       r = drop (length l         ) ys
>   in Branch y l r

  </pre>
  </div>
  <div>
  <pre language=haskell class=signature>

> fromListA :: Monad m => In a (TreeF v) m => [v] -> m (TreeA a v)

  </pre><pre language=haskell>

> fromListA = anaA fromListCoalg

  </pre>
  </div>

</div>
<footer></footer>
</div>

<!-- ====================================================================== -->

<div class=slide>
<header><div class=slidenumber></div></header>
<div class=body>
  <div class=vindent>
  <pre language=haskell class=signature>

> squares :: IO (TreeA Debug (Int, Int))

  </pre><pre language=haskell>

> squares = fromListA [(1,1),(2,4),(3,9)]

  </pre><pre>
<strong>ghci></strong> squares
("In",Leaf)
("In",Leaf)
("In",Branch (2,4) () ())
("In",Leaf)
("In",Leaf)
("In",Branch (3,9) () ())
("In",Branch (1,1) () ())
<span style=color:#080>{D (Branch (1,1) {D (Branch (2,4) {D Leaf} {D Leaf})}
                 {D (Branch (3,9) {D Leaf} {D Leaf})})}</span></pre>
  </div>

</div>
<footer></footer>
</div>

<!-- ====================================================================== -->

<div class=slide>
<header><h1>Catamorphism</h1><div class=slidenumber></div></header>
<div class=body>
  <div>
  <p class=center>Like Haskell's <code>fold</code>.</p>
  </div>
  <div class=vindent>
  <p>Algebra type:</p>
  <pre language=haskell>

> type Alg f r = f r -> r

  </pre>
  </div>
  <div>
  <p>Recursive catamorphic traversal:</p>
  <pre language=haskell class=signature>

> cataA :: (Monad m, Functor m, Out a f m, Traversable f)
>       => Alg f r -> FixA a f -> m r

  </pre><pre language=haskell>

> cataA alg = return . alg <=< mapM (cataA alg) <=< outA

  </pre>
  </div>
</div>
<footer></footer>
</div>

<!-- ====================================================================== -->

<div class=slide>
<header><h1>Lookup on binary tree</h1><div class=slidenumber></div></header>
<div class=body>
  <div class=vindent>
  <pre language=haskell class=signature>

> lookupAlg :: Ord k => k -> Alg (TreeF (k, v)) (Maybe v)

  </pre><pre language=haskell>

> lookupAlg k (Branch (w, v) l r) =
>   case k `compare` w of
>              LT -> l
>              EQ -> Just v
>              GT -> r
> lookupAlg _ Leaf = Nothing

  </pre>
  </div>
  <div>
  <pre language=haskell class=signature>

> lookupA :: (Ord k, Monad m, Functor m, Out a (TreeF (k, v)) m)
>         => k -> TreeA a (k, v) -> m (Maybe v)

  </pre><pre language=haskell>

> lookupA k = cataA (lookupAlg k)

  </pre>
  </div>

</div>
<footer></footer>
</div>

<!-- ====================================================================== -->

<div class=slide>
<div class=body>
  <div class=vindent>
  <pre>
<strong>ghci></strong> squares >>= lookupA 3
("In",Leaf)
("In",Leaf)
("In",Branch (2,4) () ())
("In",Leaf)
("In",Leaf)
("In",Branch (3,9) () ())
("In",Branch (1,1) () ())
("Out",Branch (1,1) () ())
("Out",Branch (2,4) () ())
("Out",Leaf)
("Out",Leaf)
("Out",Branch (3,9) () ())
("Out",Leaf)
("Out",Leaf)
<em>Just 9</em></pre>
  </div>
</div>
<footer></footer>
</div>



<!--

> {-# LANGUAGE
>     MultiParamTypeClasses
>   , FlexibleInstances
>   , FlexibleContexts
>   , UndecidableInstances
>   , ScopedTypeVariables
>   , DeriveFunctor
>   , DeriveFoldable
>   , DeriveTraversable
>   , KindSignatures
>   , RankNTypes
>   , GADTs
>   , GeneralizedNewtypeDeriving
>   , EmptyDataDecls
>   #-}
> module Backup where

> import Data.Traversable
> import Control.Applicative
> import Control.Monad hiding (mapM)
> import Control.Monad.State hiding (mapM)
> import Prelude hiding (read, mapM)
> import Data.Binary hiding (get)
> import Heap
> import Generics
> import Storage
> import qualified Data.Map as M

-->

<!-- ====================================================================== -->

<div class=slide>
<header><h1>Modification</h1><div class=slidenumber></div></header>
<div class=body>
  <div>
  <p>Modify a node inside an annotation.</p>
  <pre language=haskell class=signature>

> class (Out a f m, In a f m) => OutIn a f m where
>   annIO :: (f (FixA a f) -> m (f (FixA a f)))
>         -> FixA a f      -> m (FixA a f)

  </pre>
  </div>
  <div>
  <p>Default implementation performs unwrap/wrap:</p>
  <pre language=haskell>

>   annIO f = inA <=< f <=< outA

  </pre>
  </div>
  <div>
  <p>Pointer instance.</p>
  <pre language=haskell class=signature>

> instance Binary (f (FixA P f)) => OutIn P f Heap
>    where annIO g (InA (P f)) =
>                InA . P <$> (write =<< g =<< fetch f)

  </pre>
  <pre language=haskell class=helper>

> fetch :: Binary a => Pointer a -> Heap a

  </pre>
  </div>
</div>
</div>

<!--

> fetch = undefined

-->

<!-- ====================================================================== -->

<div class=slide>
<header><h1>Endomorphic Paramorphism</h1><div class=slidenumber></div></header>
<div class=body>
  <div>
  <p>Algebra type:</p>
  <pre language=haskell>

> type Endo f a = f (FixA a f, FixA a f) -> FixA a f

  </pre>
  </div>
  <div>
  <p>Recursive endo-paramorphic traversal:</p>
  <pre language=haskell class=signature>

> endoA :: (Functor m, OutIn a f m, Traversable f)
>       => Endo f a -> FixA a f -> m (FixA a f)

  </pre>
  </div>
  <div>
  <p>Insert algebra:</p>
  <pre language=haskell class=signature>

> insert :: Ord v => v -> Endo (TreeF v) a

  </pre>
  </div>
</div>
<footer></footer>
</div>

<!--

> endoA = undefined
> insert = undefined

-->

<!-- ====================================================================== -->

<div class=slide>
<header><h1>Allocate</h1><div class=slidenumber></div></header>
<div class=body>
  <div class="vindent">
  <p>Allocate scans the in-memory allocation map for a free block.</p>
  <pre language=haskell class=signature>

> allocate :: Integer -> Heap (Pointer a)

  </pre><pre language=haskell>

> allocate size =
>   do (end, unused) <- get               -- from StateT
>      case atLeast size unused of
>        offset:_ -> useBlockAt offset -- from map
>        _        -> useBlockAt end          -- grow heap
>   where atLeast s = M.elems . M.filter (>= s)

  </pre><pre language=haskell class="signature helper">

> useBlockAt :: Integer -> Heap (Pointer a)

  </pre>

<!--

> useBlockAt = undefined

-->
  </div>
</div>
<footer></footer>
</div>

<!-- ====================================================================== -->

<div class=slide>
<header><h1>Indexed datatypes</h1><div class=slidenumber></div></header>
<div class=body>
  <div>
  <p>Higher order annotated fixed point.</p>
  <pre language=haskell class=signature>

> data HFixA
>     (a  :: ((* -> *) -> * -> *) -> (* -> *) -> * -> *)
>     (f  ::  (* -> *) -> * -> *)
>     (ix ::   *)
>   = HInA { houta :: a f (HFixA a f) ix }

  </pre>
  </div>
  <div>
  <p>Higher order pointer annotation.</p>
  <pre language=haskell>

> newtype HP
>         (f  :: (* -> *) -> * -> *)
>         (b  ::  * -> *)
>         (ix ::  *)
>       = HP { unHP :: Pointer (f b ix) }

  </pre>
  </div>
</div>
<footer></footer>
</div>

<!-- ====================================================================== -->

<!--

> data Z
> data S c

-->

<div class=slide>
<div class=body>
  <div>
  <pre language=haskell class=signature>

> data Sp ; data Dg ; data Nd

  </pre><pre language=haskell class=signature>

> data FT (v :: *) (f :: * -> *) :: * -> * where
>   Empty  ::                              FT v f (Sp, S c)
>   Single :: f (Dg, S c)               -> FT v f (Sp, S c)
>   Deep   :: f (Dg, S c)
>          -> f (Sp, S (S c))           
>          -> f (Dg, S c)               -> FT v f (Sp, S c)
>   Digit1 :: f (Nd, c)                 -> FT v f (Dg, S c)
>   Digit2 :: f (Nd, c) -> f (Nd, c)    -> FT v f (Dg, S c)
>   Digit3 :: f (Nd, c) -> f (Nd, c)    
>          -> f (Nd, c)                 -> FT v f (Dg, S c)
>   Digit4 :: f (Nd, c) -> f (Nd, c)    
>          -> f (Nd, c) -> f (Nd, c)    -> FT v f (Dg, S c)
>   Node2  :: f (Nd, c) -> f (Nd, c)    -> FT v f (Nd, S c)
>   Node3  :: f (Nd, c) -> f (Nd, c)    
>          -> f (Nd, c)                 -> FT v f (Nd, S c)
>   Value  :: v                         -> FT v f (Nd, Z)

  </pre><pre language=haskell class=signature>

> type FingerTreeP v = HFixA HP (FT v) (Sp, S Z)

  </pre>
  </div>
</div>
<footer></footer>
</div>

<div class=slide>
<div class=body>
  <div>
  <center>
  <img class=tall src=img/fingertree.pdf>
  </center>
  </div>
</div>
</div>

<!-- ====================================================================== -->

<!--#include virtual=more.html -->


<!--

> {-# LANGUAGE
>     MultiParamTypeClasses
>   , FlexibleInstances
>   , FlexibleContexts
>   , UndecidableInstances
>   , ScopedTypeVariables
>   , DeriveFunctor
>   , DeriveFoldable
>   , DeriveTraversable
>   , KindSignatures
>   , RankNTypes
>   #-}
> module Storage where

> import Control.Monad
> import Control.Monad.Trans
> import Control.Applicative
> import Prelude hiding (read)
> import Data.Binary
> import Heap
> import Generics
> import Morphisms
> import qualified Prelude as Prelude

-->

<!-- ====================================================================== -->

<div class="slide chapter">
<header><h1>Persistent Data Structures</h1></header>
</div>

<!-- ====================================================================== -->

<div class=slide>
<header><h1>Pointer annotation</h1><div class=slidenumber></div></header>
<div class=body>
  <div class=vindent>
  <p>Wrapped pointer annotation.</p>
  <pre language=haskell>

> newtype P f a = P { unP :: Pointer (f a) }

  </pre>
  </div>
  <div>
  <p>Unwrapping means reading from heap.</p>
  <pre language=haskell>

> instance Binary (f (FixA P f)) => AnnOut P f Heap
>    where annOut (InA (P f)) = read f

  </pre>
  <p>Wrapping means writing to heap.</p>
  <pre language=haskell>

> instance Binary (f (FixA P f)) => AnnIn P f Heap
>    where annIn f = InA . P <$> write f

  </pre>
  </div>

</div>
<footer></footer>
</div>

<!-- ====================================================================== -->

<div class=slide>
<header><h1>Persistent operations</h1><div class=slidenumber></div></header>
<div class=body>
  <div class=vindent>
  <pre language=haskell>

> type PersistentTree k = FixA P (TreeF k)

  </pre>
  </div>
  <div>
  <p>Build a tree on disk.</p>
  <pre language=haskell class=signature>

> fromListP :: [v] -> Heap (PersistentTree v)

  </pre><pre language=haskell>

> fromListP = fromListA

  </pre>
  </div>
  <div>
  <p>Lookup value from tree on disk.</p>
  <pre language=haskell class=signature>

> lookupP :: Ord k => k
>         -> PersistentTree (k, v) -> Heap (Maybe v)

  </pre><pre language=haskell>

> lookupP = lookupA

  </pre>
  </div>

</div>
<footer></footer>
</div>

<div class=slide>
<div class=body>
  <div class=vindent>
  <pre language=haskell>fromListP [3,1,4,7]</pre>
  <center>
  <img class=long src=img/binarytree-pers.pdf>
  </center>
  </div>
</div>
</div>

<!-- ====================================================================== -->

<div class=slide>
<header><h1>Creating square database</h1><div class=slidenumber></div></header>
<div class=body>
  <div class=vindent>
  <p><code>BuildSquareDB.hs</code></p>
  <pre language=haskell class=signature>

> main :: IO ()

  </pre>
  <pre language=haskell>

> main =
>   do run "squares.db" $
>        do p <- fromListP (map (\a -> (a, a*a)) [1..10])
>           storeRootPtr (p :: FixA P (TreeF (Int, Int)))
>      putStrLn "Database created."

  </pre>
  <pre language=haskell class=helper>

> storeRootPtr :: FixA P f -> Heap ()

  </pre>
  </div>

</div>
<footer></footer>
</div>

<!--

> storeRootPtr = undefined

-->

<!-- ====================================================================== -->

<div class=slide>
<header><h1>Looking up squares</h1><div class=slidenumber></div></header>
<div class=body>
  <div class=vindent>
  <p><code>LookupSquares.hs</code></p>
  <pre language=haskell class=signature>

> main' :: IO ()

  </pre>
  <pre language=haskell>

> main' =
>   run "squares.db" $ forever $
>     do liftIO $ putStr "Give a number> "
>        num <- Prelude.read <$> liftIO getLine
>        sqr <- fetchRootPtr >>= lookupP num  -- actual lookup
>        liftIO $ print ( num :: Int
>                       , sqr :: Maybe Int
>                       )

  </pre>
  <pre language=haskell class=helper>

> fetchRootPtr :: Heap (FixA P f)

  </pre>
  </div>

<!--

> fetchRootPtr = undefined

-->

</div>
<footer></footer>
</div>

<!-- ====================================================================== -->

<div class=slide>
<div class=body>
  <div>
  <pre class=signature>
<em>$ ghc --make BuildSquareDB.hs -o build-squares-db</em>
<em>$ ghc --make LookupSquares.hs -o lookup-squares</em>
...
<em>$ ./build-square-db</em>
Database created.
<em>$ ls *.db</em>
squares.db
<em>$ hexdump squares.db</em>
0000000 54 68 69 73 20 69 73 20 6a 75 73 74 20 61 20 66
0000010 61 6b 65 20 65 78 61 6d 70 6c 65 21 21 21 21 0a
...
<em>$ ./lookup-squares</em>
Give a number&gt; 3
(3, Just 9)
Give a number&gt; 9
(9, Just 81)
Give a number&gt; 12
(12, Nothing)
^C
<em>$ _</em></pre>
  </div>

</div>
<footer></footer>
</div>


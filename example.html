<!--

> module Example where

> import Data.Map (Map)
> import Prelude hiding (lookup)
> import qualified Data.Map as M
> import Control.Concurrent.STM

-->

<!-- ====================================================================== -->

<div class=slide>
<header><h1>Example, user database</h1><div class=slidenumber></div></header>
<div class=body>
  <div>
  <p>User datatype containing email and password.</p>
  <pre language=haskell class=signature>

> type Email    = String

  </pre>
  <pre language=haskell class=signature>

> type Password = String

  </pre>
  <pre language=haskell>

> data User     = User
>               { email    :: Email
>               , password :: Password
>               }

  </pre>
  </div>
  <div>
  <p>User database as mapping from email to user.</p>
  <pre language=haskell>

> type UserDB = Map Email User

  </pre>
  </div>
</div>
<footer></footer>
</div>

<!-- ====================================================================== -->

<div class=slide>
<header><h1>Example, performing a signup</h1><div class=slidenumber></div></header>
<div class=body>
  <div class=vindent>
  <p>Add a new user to a database, the email address must be unique.</p>
  <pre language=haskell class=signature>

> signup :: UserDB -> User -> Either String UserDB

  </pre>
  <pre language=haskell>

> signup db user = 
>   let mail = email user in
>   case M.lookup mail db of
>     Nothing -> Right (M.insert mail user db)
>     Just _  -> Left "email already taken"

  </pre>
  </div>
</div>
<footer></footer>
</div>

<!-- ====================================================================== -->

<div class=slide>
<header><h1>Example, authenticate a user</h1><div class=slidenumber></div></header>
<div class=body>
  <div class=vindent>
  <p>Does the database contain a user with the right email and password?</p>
  <pre language=haskell class=signature>

> authenticate :: UserDB -> User -> Bool

  </pre>
  <pre language=haskell>

> authenticate db user = 
>   case M.lookup (email user) db of
>     Just (User _ p) | p == password user -> True
>     _                                    -> False

  </pre>
  </div>
</div>
<footer></footer>
</div>

<!-- ====================================================================== -->

<div class=slide>
<header><h1>Map as binary tree</h1><div class=slidenumber></div></header>
<div class=body>
  <div class=vindent>
  <p>Haskell's <code>Data.Map</code> is implemented as a size balanced binary tree.</p>
  </div>
  <div>
  <p>A simplified binary tree, without key:</p>
  <pre language=haskell>

> data Tree v =
>     Leaf
>   | Branch { value :: v
>            , left  :: Tree v
>            , right :: Tree v
>            }

  </pre>
  </div>
</div>
<footer></footer>
</div>

<!-- ====================================================================== -->

<div class=slide>
<header><h1>Insertion into binary tree</h1><div class=slidenumber></div></header>
<div class=body>
  <div class=vindent>
  <pre language=haskell class=signature>

> insert :: Ord v => v -> Tree v -> Tree v

  </pre>
  <pre language=haskell>

> insert v (Branch w l r) =
>   case v `compare` w of
>           LT -> Branch w (insert v l) r
>           EQ -> Branch v l r
>           GT -> Branch w l (insert v r)
> insert v Leaf = Branch v Leaf Leaf

  </pre>
  </div>
</div>
<footer></footer>
</div>

<!-- ====================================================================== -->

<div class=slide>
<header><h1>Lookup on binary tree</h1><div class=slidenumber></div></header>
<div class=body>
  <div class=vindent>
  <pre language=haskell class=signature>

> lookup :: Ord k => k -> Tree (k, v) -> Maybe v

  </pre>
  <pre language=haskell>

> lookup k (Branch (w, v) l r) =
>   case k `compare` w of
>           LT -> lookup k l
>           EQ -> Just v
>           GT -> lookup k r
> lookup _ Leaf = Nothing

  </pre>
  </div>
</div>
<footer></footer>
</div>

<!-- ====================================================================== -->

<!--

> type Web a = IO a
> getPostVar :: String -> IO String
> getPostVar = undefined

-->

<div class=slide>
<header><h1>Example, web application</h1><div class=slidenumber></div></header>
<div class=body>
  <div class=vindent>
  <p>Get post data out of web environment and try signup.</p>
  <pre language=haskell class=signature>

> signupHandler :: TVar UserDB -> Web String

  </pre>
  <pre language=haskell>

> signupHandler dbVar =
>   do mail <- getPostVar "email"
>      pass <- getPostVar "password"
>      atomically $
>        do db <- readTVar dbVar
>           case signup db (User mail pass) of
>             Left  err -> return ("failed: " ++ err)
>             Right db' -> do writeTVar dbVar db'
>                             return "signup ok"

  </pre>
  </div>
</div>
<footer></footer>
</div>

<!-- ====================================================================== -->

